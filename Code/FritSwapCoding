// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract FrithToFritSwap {
    address public owner;
    IERC20 public frith; // token users give
    IERC20 public frit;  // token contract holds and pays out
    uint256 public rate; // frit units per 1 frith (e.g., 10 => 1 FRITH = 10 FRIT)
    bool public paused;

    // Reentrancy simple guard
    uint256 private _status;
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    event Swapped(address indexed user, uint256 frithIn, uint256 fritOut);
    event Deposit(address indexed token, uint256 amount);
    event Withdraw(address indexed token, uint256 amount);
    event RateChanged(uint256 oldRate, uint256 newRate);
    event Paused(bool isPaused);
    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    modifier nonReentrant() {
        require(_status != _ENTERED, "Reentrant");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }

    modifier whenNotPaused() {
        require(!paused, "Paused");
        _;
    }

    constructor(address _frith, address _frit, uint256 _initialRate) {
        require(_frith != address(0) && _frit != address(0), "Zero address");
        owner = msg.sender;
        frith = IERC20(_frith);
        frit = IERC20(_frit);
        rate = _initialRate;
        paused = false;
        _status = _NOT_ENTERED;
    }

    // Public swap: user must approve this contract to spend frithAmount FRITH before calling.
    function swap(uint256 frithAmount) external nonReentrant whenNotPaused {
        require(frithAmount > 0, "Zero amount");
        // Calculate frit to send: fritAmount = frithAmount * rate
        uint256 fritAmount = frithAmount * rate;

        // Ensure contract has enough FRIT to pay
        uint256 fritBalance = frit.balanceOf(address(this));
        require(fritBalance >= fritAmount, "Insufficient FRIT liquidity");

        // Pull FRITH from user
        bool okIn = frith.transferFrom(msg.sender, address(this), frithAmount);
        require(okIn, "FRITH transfer failed");

        // Send FRIT to user
        bool okOut = frit.transfer(msg.sender, fritAmount);
        require(okOut, "FRIT transfer failed");

        emit Swapped(msg.sender, frithAmount, fritAmount);
    }

    // Owner: deposit FRIT or FRITH into the contract (token must be approved to owner then transferred)
    // Prefer using token's own transferFrom to move tokens into this contract for accounting.
    function depositToken(address token, uint256 amount) external onlyOwner {
        require(amount > 0, "Zero amount");
        bool ok = IERC20(token).transferFrom(msg.sender, address(this), amount);
        require(ok, "Deposit transfer failed");
        emit Deposit(token, amount);
    }

    // Owner: withdraw tokens from contract
    function withdrawToken(address token, uint256 amount, address to) external onlyOwner {
        require(amount > 0, "Zero amount");
        require(to != address(0), "Zero recipient");
        bool ok = IERC20(token).transfer(to, amount);
        require(ok, "Withdraw transfer failed");
        emit Withdraw(token, amount);
    }

    // Owner controls
    function setRate(uint256 newRate) external onlyOwner {
        require(newRate > 0, "Rate zero");
        uint256 old = rate;
        rate = newRate;
        emit RateChanged(old, newRate);
    }

    function setPaused(bool on) external onlyOwner {
        paused = on;
        emit Paused(on);
    }

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Zero owner");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}
